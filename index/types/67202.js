// This file was generated by docs-search
window.DocsSearchTypeIndex["67202"] = {"tag":"Just","value":[{"comments":"## Partial Person\n`Person`, but all fields wrapped in `Maybe` to indicate their\npresence (or lack of presence)\n","hashAnchor":"t","info":{"tag":"typeSynonym","value":{"arguments":[],"type":{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Record"]},{"tag":"TypeConstructor","annotation":null,"contents":[["ACMECorp","Person"],"PartialPersonRow"]}]}}},"moduleName":"ACMECorp.Person","name":"PartialPerson","packageInfo":{"tag":"local"},"score":0,"sourceSpan":{"end":{"column":45,"line":73},"name":"src/ACMECorp.Person.purs","start":{"column":1,"line":73}}},{"comments":"## Person Record\n\n### Usage\nConsidering two usecases for \"partial input needing validation\"\nin the module documentation:\n- Partial HTTP Patch\n- UI Form input\n\n#### Partial HTTP PATCH\nA partial record of this row type is deserialized from JSON sent by\nclients into `PartialPerson`. (see `decodePartialPerson`)\n\nData validation is deferred to the corresponding JSON (de)serialization\ninstances for the individual fields.\n\nBecause the record is partial, and we can't access fields that may not\nbe present, we use a helper of some kind (see stub `class ExpandFields`)\nto convert the partial row type to a hard record with present fields\nwrapped in `Just` and missing fields set to `Nothing`.\n\nWe commit the new state from `Just`s to persistent state (database), and\ndo nothing on the fields set to `Nothing`.\n\n**Note**: A vitally important part of PATCH contracts in my experience is\nthat using a field's **presence** in a PATCH record, rather than `null`\nor non-`null` allows disambiguating between clearing an optional field\nvs not updating it.\n\n#### Form Input\nForm state is `PartialPerson`, where as the user progresses through\nthe form, the fields are set to `Just`.\n\nPhone & SSN validation performed by `Data.Telecom.Phone.fromString` and\n`Data.USGov.SocialSecurityNumber.fromString` respectively.\n\nValidating `MaritalStatus` unnecessary because the frontend should\nuse classes (`BoundedEnum` or similar) to enumerate over the variants\ndriving dropdown values directly.\n\nMay be worth considering a dual of `class ExpandFields` like\n`class ContractFields` that un-maybes the values so we can PATCH it easily.\n\nIn the past I've written a typelevel Form abstraction\nwhich would capture the progressively-filled-out and potentially invalid\nstate of building a record in this way.\n","hashAnchor":"t","info":{"tag":"typeSynonym","value":{"arguments":[],"type":{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Record"]},{"tag":"TypeConstructor","annotation":null,"contents":[["ACMECorp","Person"],"PersonRow"]}]}}},"moduleName":"ACMECorp.Person","name":"Person","packageInfo":{"tag":"local"},"score":0,"sourceSpan":{"end":{"column":31,"line":60},"name":"src/ACMECorp.Person.purs","start":{"column":1,"line":60}}},{"comments":"Reversed polymorphic Type application\n\nFor example...\n```\nFLIP Int Maybe == Int # Maybe == Maybe Int\n```\n","hashAnchor":"t","info":{"tag":"typeSynonym","value":{"arguments":[{"name":"a"},{"name":"f"}],"type":{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeVar","annotation":null,"contents":"f"},{"tag":"TypeVar","annotation":null,"contents":"a"}]}}},"moduleName":"Type.Function","name":"FLIP","packageInfo":{"tag":"package","value":"typelevel-prelude-7.0.0"},"score":0,"sourceSpan":{"end":{"column":20,"line":21},"name":".spago/p/typelevel-prelude-7.0.0/src/Type/Function.purs","start":{"column":1,"line":21}}},{"comments":"Polymorphic Type application\n\nFor example...\n```\nAPPLY Maybe Int == Maybe $ Int == Maybe Int\n```\n","hashAnchor":"t","info":{"tag":"typeSynonym","value":{"arguments":[{"name":"f"},{"name":"a"}],"type":{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeVar","annotation":null,"contents":"f"},{"tag":"TypeVar","annotation":null,"contents":"a"}]}}},"moduleName":"Type.Function","name":"APPLY","packageInfo":{"tag":"package","value":"typelevel-prelude-7.0.0"},"score":0,"sourceSpan":{"end":{"column":21,"line":10},"name":".spago/p/typelevel-prelude-7.0.0/src/Type/Function.purs","start":{"column":1,"line":10}}},{"comments":"Type application for rows.\n","hashAnchor":"t","info":{"tag":"typeSynonym","value":{"arguments":[{"name":"f"},{"name":"a"}],"type":{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeVar","annotation":null,"contents":"f"},{"tag":"TypeVar","annotation":null,"contents":"a"}]}}},"moduleName":"Type.Row","name":"RowApply","packageInfo":{"tag":"package","value":"typelevel-prelude-7.0.0"},"score":0,"sourceSpan":{"end":{"column":24,"line":11},"name":".spago/p/typelevel-prelude-7.0.0/src/Type/Row.purs","start":{"column":1,"line":11}}}]}