// This file was generated by docs-search.
window.DocsSearchIndex["37"] = [["~=",[{"hashAnchor":"v","info":{"tag":"valueAlias"},"moduleName":"Data.Number.Approximate","name":"(~=)","packageInfo":{"tag":"package","value":"numbers-9.0.1"},"score":0,"sourceSpan":{"end":{"column":28,"line":69},"name":".spago/p/numbers-9.0.1/src/Data/Number/Approximate.purs","start":{"column":1,"line":69}}}]],["zshr",[{"comments":"Bitwise zero-fill shift right.\n","hashAnchor":"v","info":{"tag":"value","value":{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Int"]}]},{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Int"]}]}]}},"moduleName":"Data.Int.Bits","name":"zshr","packageInfo":{"tag":"package","value":"integers-6.0.0"},"score":0,"sourceSpan":{"end":{"column":41,"line":34},"name":".spago/p/integers-6.0.0/src/Data/Int/Bits.purs","start":{"column":1,"line":34}}}]],["type",[{"comments":"`Type` is the kind of all proper types: those that classify value-level terms.\nFor example the type `Boolean` has kind `Type`; denoted by `Boolean :: Type`.\n","hashAnchor":"t","info":{"tag":"externData","value":{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Type"]}},"moduleName":"Prim","name":"Type","packageInfo":{"tag":"builtin"},"score":0}]],["typeequals",[{"comments":"This type class asserts that types `a` and `b`\nare equal.\n\nThe functional dependencies and the single\ninstance below will force the two type arguments\nto unify when either one is known.\n\nNote: any instance will necessarily overlap with\n`refl` below, so instances of this class should\nnot be defined in libraries.\n","hashAnchor":"t","info":{"tag":"typeClass","value":{"arguments":[{"name":"a"},{"name":"b"}],"fundeps":[[["a"],["b"]],[["b"],["a"]]],"superclasses":[{"constraintAnn":null,"constraintArgs":[{"tag":"TypeVar","annotation":null,"contents":"a"},{"tag":"TypeVar","annotation":null,"contents":"b"}],"constraintClass":[["Prim","Coerce"],"Coercible"],"constraintData":null,"constraintKindArgs":[]}]}},"moduleName":"Type.Equality","name":"TypeEquals","packageInfo":{"tag":"package","value":"type-equality-4.0.1"},"score":0,"sourceSpan":{"end":{"column":32,"line":22},"name":".spago/p/type-equality-4.0.1/src/Type/Equality.purs","start":{"column":1,"line":21}}}]],["typemismatch",[{"hashAnchor":"v","info":{"tag":"dataConstructor","value":{"dataDeclType":"data","type":{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeApp","annotation":null,"contents":[{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","annotation":null,"contents":[["Prim"],"String"]}]},{"tag":"TypeConstructor","annotation":null,"contents":[["Data","Argonaut","Decode","Error"],"JsonDecodeError"]}]}}},"moduleName":"Data.Argonaut.Decode.Error","name":"TypeMismatch","packageInfo":{"tag":"package","value":"argonaut-codecs-9.1.0"},"score":0,"sourceSpan":{"end":{"column":17,"line":12},"name":".spago/p/argonaut-codecs-9.1.0/src/Data/Argonaut/Decode/Error.purs","start":{"column":3,"line":12}}}]],["%",[{"hashAnchor":"v","info":{"tag":"valueAlias"},"moduleName":"Data.Number","name":"(%)","packageInfo":{"tag":"package","value":"numbers-9.0.1"},"score":0,"sourceSpan":{"end":{"column":24,"line":218},"name":".spago/p/numbers-9.0.1/src/Data/Number.purs","start":{"column":1,"line":218}}}]]]